/***
 *** SynQ: SYNtactic Quantification of grammar complexity.
 *** Copyright 2004 James F. Power, NUI Maynooth, Ireland <jpower@cs.nuim.ie>
 *** This version: 16 August 2004
 ***
 *** This program is free software; you can redistribute it and/or modify
 *** it under the terms of the GNU General Public License as published by
 *** the Free Software Foundation; either version 2 of the License, or
 *** (at your option) any later version.
 ***
 *** This program is distributed in the hope that it will be useful,
 *** but WITHOUT ANY WARRANTY; without even the implied warranty of
 *** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *** GNU General Public License for more details.
 ***
 *** You should have received a copy of the GNU General Public License
 *** along with this program; if not, write to the Free Software
 *** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 ***/


/** \file main.cpp
 **
 ** Handles command line input, and contains the functions that print
 ** the metrics.
 **/

#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <cmath>   // For rint

 
#include "Grammar.h"

/** The parsing routine generated by bison; returns 0 if the parse went OK */
extern int yyparse();

/** The file that bison reads its input from; allow the user to change this.
 ** The default value (assigned by bison) is standard input.
 **/
extern FILE * yyin;

/** A single instance of the grammar object.  
 ** Not static, since it must be visible to lex.yy.c.
 ** Should probably have made this a singleton class...
 **/
Grammar theGrammar;  


/** Just print out the count of symbols, average size and McCabe */
void 
printSimpleResults(std::ostream &out)
{
  out << theGrammar.countTerminals() << " "
      << theGrammar.countNonTerminals() << " "
      << theGrammar.calcMcCabe() << " "
      << setprecision(2) << theGrammar.averageSize() << endl;
}

/** Just print the grammar-level sizes, one per line */
void 
printLevelSizes(std::ostream &out)
{
  theGrammar.makeDerivesRelation();
  //  out << setprecision(3) << theGrammar.getManyImpurity() << std::endl;
  theGrammar.makeEquivClasses();
  theGrammar.printEquivClassSizes(out);
}

/** Summarise all the results on a single line (handy for tables) */
void 
printBriefResults(std::ostream &out)
{
  out << theGrammar.countTerminals() << " : ";
  out << theGrammar.countNonTerminals() << " : ";
  out << theGrammar.calcMcCabe() << " : ";
  out << (int)rint(theGrammar.calcHalstead()/1000.0) << " : ";
  out << setprecision(2) << theGrammar.averageSize() << " : ";
  theGrammar.makeDerivesRelation();
  out << setprecision(3) << theGrammar.getManyImpurity() << " : ";
  theGrammar.makeEquivClasses();
  out << theGrammar.countEquivClasses() << " : ";
  out << setprecision(3) << theGrammar.countNormEquivClasses() << " : ";
  out << theGrammar.countEquivClasses(1) << " : ";
  out << theGrammar.getLargestEquivClassSize() << " : ";
  out << setprecision(3) << theGrammar.calcHeight() << std::endl;
}

/** The full results output, showing all the metrics as well as the
 ** derives relationship and equivalence classes.
 **
 ** The following is the full list of the data that is printed:
 **  - The grammar rules
 **  - The number of terminals and non-terminals
 **  - The McCabe complexity value for the whole grammar
 **  - The Halstead volume value for the whole grammar
 **  - The average RHS size
 **  - The derives-in-one relation, as a 2D array, indexed by non-ts
 **  - The derives-in-many relation, as a 2D array, indexed by non-ts
 **  - Fenton's tree impurity value for the derives-in-one relation
 **  - Fenton's tree impurity value for the derives-in-many relation
 **  - The equivalence classes, listed by number, along with with 
 **    their contents (non-terminals)
 **  - The number of equiv. classes, the number that are non-singleton
 **  - The number of equiv. classes as a %age of the number of non-ts
 **  - The size (no. of nonterminals) of the largest equiv. class
 **  - The value of the Varju height metric
 **  - The equivalence relation, printed as a 2D matrix indexed by 
 **     equivalence class numbers
 **/
void 
printResults(std::ostream &out)
{
  out << "The grammar: " << std::endl;
  out << theGrammar;
  out << ">>> There are " << theGrammar.countTerminals() << " terminals "
      << "and " << theGrammar.countNonTerminals() << " non-terminals " 
      << std::endl;
  if (theGrammar.printUndefined(out)) {
    std::cerr << "There are undefined nonterminals" << std::endl;
    exit(1);
  }  
  out << ">>> Total McCabe complexity is: " 
      << theGrammar.calcMcCabe() << std::endl;
  theGrammar.printMcCabe(out);
  out << ">>> Total Halstead volume is: " 
      << theGrammar.calcHalstead() << std::endl;
  out << ">>> Average RHS Size is: " << theGrammar.averageSize() << std::endl;
  theGrammar.makeDerivesRelation();
  theGrammar.printDerivesRelation(out);
  out << "Fenton impurity is: " << theGrammar.getOneImpurity() << std::endl;
  out << ">>> Fenton closed impurity is: " 
      << theGrammar.getManyImpurity() << std::endl;
  theGrammar.makeEquivClasses();
  theGrammar.printEquivClasses(out);
  out << ">>> There are " << theGrammar.countEquivClasses(0) 
      << " equivalence classes, "  << theGrammar.countEquivClasses(1) 
      << " of which are non-singleton" << std::endl;
  out << "As a percentage of the number of non-terminals, there are "
      << setprecision(3) << theGrammar.countNormEquivClasses() 
      << "% equivalence classes " << std::endl;
  out << ">>> (Depth) Largest equivalence class has " 
      << theGrammar.getLargestEquivClassSize() 
      << " non-terminals" << std::endl;
  out << "Varju height metric is: " << theGrammar.calcHeight() << std::endl;
  theGrammar.printEquivGraph(out);
}

/** This pointer is set to one of the above print functions, based on
 ** command-line swtiches.
 **/
static void (*printFunction)(std::ostream &) = printResults;

/** Print usage information and exit. */
static void
printUsageAndExit(const char *progname, int exitval)
{
    std::cerr << "Usage: " << progname 
              << " [options] [grammarfile.y]" << std::endl;
    std::cerr << "Options are:" << std::endl;
    std::cerr << "\t-b : Print brief (one line) results only" << std::endl;
    std::cerr << "\t-h : Print this help message" << std::endl;
    std::cerr << "\t-l : Print level sizes only" << std::endl;
    std::cerr << "\t-s : Print symbols, RHS and McCabe counts only" << std::endl;
    std::cerr << "\t-v : Print version number and exit" << std::endl;
    exit(exitval);
}

/** Process the command line arguments, setting printFunction and yyin
 ** as appropriate.  Command-line switches correspond to the print
 ** functions defined above, as follows:
 **   - -b = printBriefResults
 **   - -l = printLevelSizes
 **   - -s = printSimpleResults
 **
 ** Default print function is printResults.
 **
 ** If no input file is specified by the user, then std input is used.
 **/
static void
process_arguments(int argc, char * argv[])
{
  if (argc > 3) {
    printUsageAndExit(argv[0], 1);
  }
  bool got_filename = false;
  for (int i=1; i<argc; i++) {
    if ( argv[i][0]=='-' ) {
      switch(argv[i][1]) {
      case 'b' :
      case 'B' :
        printFunction = printBriefResults;
        break;
      case 'h' :
      case 'H' :
        printUsageAndExit(argv[0], 0);
        /* Exits */
      case 'l' :
      case 'L' :
        printFunction = printLevelSizes;
        break;
      case 's' :
      case 'S' :
        printFunction = printSimpleResults;
        break;
      case 'v' :
      case 'V' :
        std::cout << "\tSynQ: SYNtactic Quantification of grammar complexity."
                  << std::endl;
        std::cout << "\tVersion 1.0 of 16 August 2004; revised 09 July 2005."
                  << std::endl;
        exit(0);
      default:
        std::cerr << "Ignoring invalid switch: " << argv[i] << std::endl;
      }
    }
    else { // Not a swtich - must be filename
      const char *filename = argv[i];
      FILE *file = fopen(filename, "r");
      if (!file) {
        std::cerr << "Could not open file \"" << filename << "\"" << std::endl;
        exit(1);
      }
      yyin = file;
      got_filename = true;
    }
  }
  if (! got_filename)
    std::cout << "Reading input from std input..." << std::endl;
}


/** Process command-line inputs, parse the file, and print the metrics */
int 
main(int argc, char * argv[]) 
{
  process_arguments(argc, argv);
  // Parse the input:
  int parseErrors = yyparse();
  if ( parseErrors ) {
    std::cerr << "Abnormal termination" << std::endl;
    return 1;
  }
  // Print the results:
  (*printFunction)(std::cout);
  return 0;
}


/** \mainpage SynQ: SYNtactic Quantification of grammar complexity.
 **
 ** Copyright 2004 James F. Power, NUI Maynooth, Ireland <jpower@cs.nuim.ie>
 **
 ** This version last edited on 16 August 2004,
 ** with minor corrections on 09 July 2005.
 ** 
 ** <h3>Directory Structure</h3>
 ** - src: The source code
 ** - html_doc: Documentation, as generated by Doxygen
 ** - grammars/standards: Grammars for various languages
 ** - grammars/parsers: Grammars from C++ parsers, mostly gcc
 **
 **
 ** <h3>For more information</h3>
 ** See: "A metrics suite for grammar-based software",
 ** by James F. Power and Brian A. Malloy,
 ** Software Maintenance and Evolution: Research and Practice, 
 ** Vol. 16, No. 6, November/December, 2004.
 **
 **
 ** <h3>GNU General Public License</h3>
 ** This program is free software; you can redistribute it and/or modify
 ** it under the terms of the GNU General Public License as published by
 ** the Free Software Foundation; either version 2 of the License, or
 ** (at your option) any later version.
 **
 ** This program is distributed in the hope that it will be useful,
 ** but WITHOUT ANY WARRANTY; without even the implied warranty of
 ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ** GNU General Public License for more details.
 **
 ** You should have received a copy of the GNU General Public License
 ** along with this program; if not, write to the Free Software
 ** Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 **/
