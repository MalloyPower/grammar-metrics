<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>SynQ: Grammar class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>Grammar Class Reference</h1>This class represents a grammar as a list of production rules.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="Grammar_8h-source.html">Grammar.h</a>&gt;</code>
<p>
Collaboration diagram for Grammar:<p><center><img src="classGrammar__coll__graph.png" border="0" usemap="#Grammar__coll__map" alt="Collaboration graph"></center>
<map name="Grammar__coll__map">
<area href="classNonTerminal.html" shape="rect" coords="7,17,113,196" alt="">
<area href="classGrammarLevels.html" shape="rect" coords="492,17,665,196" alt="">
</map>
<center><font size="2">[<a target="top" href="graph_legend.html">legend</a>]</font></center><a href="classGrammar-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#a0">Grammar</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classTerminal.html">Terminal</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#a1">addTerminal</a> (const string &amp;)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classTerminal.html">Terminal</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#a2">getTerminal</a> (const string &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the terminal symbol corresponding to this name.  <a href="#a2"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classNonTerminal.html">NonTerminal</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#a3">addNonTerminal</a> (const string &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new non terminal to the grammar.  <a href="#a3"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classNonTerminal.html">NonTerminal</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#a4">getNonTerminal</a> (const string &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the non-terminal symbol corresponding to this name.  <a href="#a4"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#a5">printUndefined</a> (ostream &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print out the non-terminals that have no definition (no RHS).  <a href="#a5"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#a6">countTerminals</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#a7">countNonTerminals</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#a8">makeDerivesRelation</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Work out the derives-in-many relationship between non-terminals.  <a href="#a8"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#a9">printDerivesRelation</a> (ostream &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the derives-in-many relationship *.  <a href="#a9"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#a10">makeEquivClasses</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Work out the set of equivalence classes based on the derives-in-many relationship.  <a href="#a10"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#a11">printEquivClasses</a> (ostream &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the list of non-terminals in each equivalence class.  <a href="#a11"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#a12">printEquivClassSizes</a> (ostream &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the sizes of the equivalence classes, one per line.  <a href="#a12"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#a13">printEquivGraph</a> (ostream &amp;out)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the graph showing the derives relationship between equivalence classes.  <a href="#a13"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>float&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#a14">countNormEquivClasses</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of equivalence classes, expressed as a percentage of the number of non-terminals.  <a href="#a14"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#a15">countEquivClasses</a> (int=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Count and return the number of equivalence classes of size &gt; minsize.  <a href="#a15"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#a16">getLargestEquivClassSize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the largest equivalence class and return its size.  <a href="#a16"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>float&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#a17">averageSize</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the average number of symbols on the RHS of the grammar rules.  <a href="#a17"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>float&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#a18">getOneImpurity</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the Fenton tree impurity value for the grammar.  <a href="#a18"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>float&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#a19">getManyImpurity</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the Fenton "closed" tree impurity value for the grammar.  <a href="#a19"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#a20">calcMcCabe</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the McCabe complexity value for the whole grammar.  <a href="#a20"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#a21">printMcCabe</a> (ostream &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the McCabe complexity value for each non-terminal.  <a href="#a21"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>float&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#a22">calcHalstead</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the Halstead volume metric for the grammar.  <a href="#a22"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>float&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#a23">calcHeight</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the Varju height metric from the grammar.  <a href="#a23"></a><br><br></td></tr>
<tr><td colspan=2><br><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#d0">calcDerivesInOne</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Work out the derives-in-one relation.  <a href="#d0"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#d1">makeEquivGraph</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the equivalence graph from the equivalence classes.  <a href="#d1"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#d2">calcGlobalHeight</a> (int, int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign a new height to an equivalence class.  <a href="#d2"></a><br><br></td></tr>
<tr><td colspan=2><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>vector&lt; <a class="el" href="classNonTerminal.html">NonTerminal</a> * &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#r0">prodRules</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">To store the production rules we just need a list of non-terminals, since each of these has a pointer to its definition.  <a href="#r0"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>vector&lt; <a class="el" href="classTerminal.html">Terminal</a> * &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#r1">terminals</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A list of all the terminal symbols used in the grammar.  <a href="#r1"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classNonTerminal.html">NonTerminal</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#r2">startSymbol</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A pointer to the start symbol (whihc is also contained in prodRules).  <a href="#r2"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classGrammarLevels.html">GrammarLevels</a> *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#r3">levels</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All the grammatical levels (derives-in-many relationship).  <a href="#r3"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>vector&lt; vector&lt; <a class="el" href="classNonTerminal.html">NonTerminal</a> * &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#r4">equivClasses</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A list of the equivalence classes, each of which is a list of equivalent non-terminals.  <a href="#r4"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>vector&lt; vector&lt; bool &gt; &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#r5">equivGraph</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The equivalence graph, effectively a NxN matrix of booleans, representing the irreflexive, anti-symmetric "can derive" relation between equivalence classes.  <a href="#r5"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>vector&lt; int &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#r6">localMcCabe</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Holds the McCabe value for each non-terminal.  <a href="#r6"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>vector&lt; int &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#r7">varjuHeight</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Holds the Varju height value for each equlvalence class.  <a href="#r7"></a><br><br></td></tr>
<tr><td colspan=2><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>ostream &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classGrammar.html#n0">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classGrammar.html">Grammar</a> &amp;gram)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This class represents a grammar as a list of production rules. 
<p>
It also provides the main methods that collect the metrics (usually by running the appropriate visitor), and some structures to hold those values. This is pretty much the central class in the whole tool; once the input grammar has been parsed, everything else is initiated from here and collected in here. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a0" doxytag="Grammar::Grammar" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Grammar::Grammar </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a3" doxytag="Grammar::addNonTerminal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classNonTerminal.html">NonTerminal</a> * Grammar::addNonTerminal </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const string &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>symbolName</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Add a new non terminal to the grammar. 
<p>
If it's the first non-terminal we've seen, make it the start symbol.     </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="Grammar::addTerminal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classTerminal.html">Terminal</a> * Grammar::addTerminal </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const string &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="Grammar::averageSize" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float Grammar::averageSize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the average number of symbols on the RHS of the grammar rules. 
<p>
This is done by applying the Size <a class="el" href="classVisitor.html">Visitor</a> to the RHS of each non-terminal in turn.     </td>
  </tr>
</table>
<a class="anchor" name="d0" doxytag="Grammar::calcDerivesInOne" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void Grammar::calcDerivesInOne </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Work out the derives-in-one relation. 
<p>
Applies the <a class="el" href="classCalcLevelsVisitor.html">CalcLevelsVisitor</a> to the rhs of each non-terminal in turn, and stores the result in the levels instance variable.     </td>
  </tr>
</table>
<a class="anchor" name="d2" doxytag="Grammar::calcGlobalHeight" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int Grammar::calcGlobalHeight </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>classNum</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>height</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Assign a new height to an equivalence class. 
<p>
This new height is then propagated to the children and descendents of this equivalence class. i.e. this is a pre-opder recursive traversal of the equivalence graph; equivalence graph must be - and is - an (acyclic) tree. Return the maximum height among this class' children.     </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="Grammar::calcHalstead" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float Grammar::calcHalstead </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the Halstead volume metric for the grammar. 
<p>
Uses a <a class="el" href="classHalsteadVisitor.html">HalsteadVisitor</a> to count the no. of operators and operands, and then applies Halstead's formula.     </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="Grammar::calcHeight" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float Grammar::calcHeight </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the Varju height metric from the grammar. 
<p>
This is the maximum distance of any non-terminal from the start symbol, and is expressed as a percentage if the number of equivalence classes.     </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="Grammar::calcMcCabe" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int Grammar::calcMcCabe </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the McCabe complexity value for the whole grammar. 
<p>
Creates a <a class="el" href="classMcCabeVisitor.html">McCabeVisitor</a> to work this out for each RHS, and stores the result in the localMcCabe instance variable.     </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="Grammar::countEquivClasses" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int Grammar::countEquivClasses </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>minsize</em> = 0          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Count and return the number of equivalence classes of size &gt; minsize. 
<p>
So countEquivClasses(0) counts them all. The size of an equiv. class is the number of non-terminals it contains.     </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="Grammar::countNonTerminals" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int Grammar::countNonTerminals </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="Grammar::countNormEquivClasses" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float Grammar::countNormEquivClasses </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the number of equivalence classes, expressed as a percentage of the number of non-terminals. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="Grammar::countTerminals" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int Grammar::countTerminals </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap> const<code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="Grammar::getLargestEquivClassSize" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int Grammar::getLargestEquivClassSize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find the largest equivalence class and return its size. 
<p>
Its size is the number of non-terminals it contains.     </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="Grammar::getManyImpurity" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float Grammar::getManyImpurity </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the Fenton "closed" tree impurity value for the grammar. 
<p>
This is calcuated over the graph where the nodes are non-terminals and the edges represent the derives-in-many relationship. The levels variable must already have been calculated.     </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="Grammar::getNonTerminal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classNonTerminal.html">NonTerminal</a> * Grammar::getNonTerminal </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const string &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>symbolName</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the non-terminal symbol corresponding to this name. 
<p>
Return NULL if not found.     </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="Grammar::getOneImpurity" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> float Grammar::getOneImpurity </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the Fenton tree impurity value for the grammar. 
<p>
This is calcuated over the graph where the nodes are non-terminals and the edges represent the derives-in-one relationship. The levels variable must already have been calculated.     </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="Grammar::getTerminal" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classTerminal.html">Terminal</a> * Grammar::getTerminal </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const string &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>symbolName</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the terminal symbol corresponding to this name. 
<p>
Return NULL if not found.     </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="Grammar::makeDerivesRelation" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void Grammar::makeDerivesRelation </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Work out the derives-in-many relationship between non-terminals. 
<p>
This is done by getting the closure of the grammatical levels. The levels are calcuated now if they have not already been.     </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="Grammar::makeEquivClasses" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void Grammar::makeEquivClasses </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Work out the set of equivalence classes based on the derives-in-many relationship. 
<p>
The result is stored in the equivClasses instance variable, where each equivalence class is a list of non-terminals. The derives-in-many tables are calcuated if they haven't been already.     </td>
  </tr>
</table>
<a class="anchor" name="d1" doxytag="Grammar::makeEquivGraph" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void Grammar::makeEquivGraph </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [private]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create the equivalence graph from the equivalence classes. 
<p>
This is a NxN matrix (N=no. of equiv classes) where a boolean indicates a dervies relationship between the classes. Result is stored in the equivGraph instance variable.     </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="Grammar::printDerivesRelation" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void Grammar::printDerivesRelation </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>out</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print the derives-in-many relationship *. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="Grammar::printEquivClasses" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void Grammar::printEquivClasses </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>out</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print the list of non-terminals in each equivalence class. 
<p>
Assumes that the classes have already been calcuated and stired in the equivClasses instance variable.     </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="Grammar::printEquivClassSizes" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void Grammar::printEquivClassSizes </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>out</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print the sizes of the equivalence classes, one per line. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="Grammar::printEquivGraph" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void Grammar::printEquivGraph </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>out</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print the graph showing the derives relationship between equivalence classes. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="Grammar::printMcCabe" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void Grammar::printMcCabe </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>out</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print the McCabe complexity value for each non-terminal. 
<p>
That is, the McCabe value for its RHS. Assumes that these have already been calculated and stored in the localMcCabe instance variable.     </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="Grammar::printUndefined" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> int Grammar::printUndefined </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>out</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Print out the non-terminals that have no definition (no RHS). 
<p>
Return a count of these non-terminals.     </td>
  </tr>
</table>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="n0" doxytag="Grammar::operator<<" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ostream&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>out</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classGrammar.html">Grammar</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>gram</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [friend]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="r4" doxytag="Grammar::equivClasses" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> vector&lt; vector&lt;<a class="el" href="classNonTerminal.html">NonTerminal</a> *&gt; &gt; <a class="el" href="classGrammar.html#r4">Grammar::equivClasses</a><code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A list of the equivalence classes, each of which is a list of equivalent non-terminals. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r5" doxytag="Grammar::equivGraph" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> vector&lt; vector&lt;bool&gt; &gt; <a class="el" href="classGrammar.html#r5">Grammar::equivGraph</a><code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The equivalence graph, effectively a NxN matrix of booleans, representing the irreflexive, anti-symmetric "can derive" relation between equivalence classes. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r3" doxytag="Grammar::levels" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classGrammarLevels.html">GrammarLevels</a>* <a class="el" href="classGrammar.html#r3">Grammar::levels</a><code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
All the grammatical levels (derives-in-many relationship). 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r6" doxytag="Grammar::localMcCabe" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> vector&lt;int&gt; <a class="el" href="classGrammar.html#r6">Grammar::localMcCabe</a><code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Holds the McCabe value for each non-terminal. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r0" doxytag="Grammar::prodRules" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> vector&lt;<a class="el" href="classNonTerminal.html">NonTerminal</a>*&gt; <a class="el" href="classGrammar.html#r0">Grammar::prodRules</a><code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
To store the production rules we just need a list of non-terminals, since each of these has a pointer to its definition. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r2" doxytag="Grammar::startSymbol" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classNonTerminal.html">NonTerminal</a>* <a class="el" href="classGrammar.html#r2">Grammar::startSymbol</a><code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A pointer to the start symbol (whihc is also contained in prodRules). 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r1" doxytag="Grammar::terminals" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> vector&lt;<a class="el" href="classTerminal.html">Terminal</a>*&gt; <a class="el" href="classGrammar.html#r1">Grammar::terminals</a><code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
A list of all the terminal symbols used in the grammar. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="r7" doxytag="Grammar::varjuHeight" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> vector&lt;int&gt; <a class="el" href="classGrammar.html#r7">Grammar::varjuHeight</a><code> [private]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Holds the Varju height value for each equlvalence class. 
<p>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Grammar_8h-source.html">Grammar.h</a><li><a class="el" href="Grammar_8cpp.html">Grammar.cpp</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Sat Jul 9 14:10:52 2005 for SynQ by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.5 </small></address>
</body>
</html>
